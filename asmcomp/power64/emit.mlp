(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* $Id: emit.mlp 9547 2010-01-22 12:48:24Z doligez $ *)

(* Emission of PowerPC assembly code *)

module StringSet = Set.Make(struct type t = string let compare = compare end)

open Location
open Misc
open Cmm
open Arch
open Proc
open Reg
open Mach
open Linearize
open Emitaux

(* Layout of the stack.  The stack is kept 16-aligned. *)

let stack_size_lbl = ref 0
let stack_slot_lbl = ref 0
let stack_args_size = ref 0
let stack_traps_size = ref 0

(* We have a stack frame of our own if we call other functions (including 
   use of exceptions, or if we need more than the red zone *)
let has_stack_frame () =
  if !contains_calls or (num_stack_slots.(0) + num_stack_slots.(1)) > (288-16)/8 then
    true
  else 
    false

let frame_size_sans_args () =
  let size = 8 * num_stack_slots.(0) + 8 * num_stack_slots.(1) + 48 in
  Misc.align size 16

let slot_offset loc cls =
  match loc with
    Local n ->
      if cls = 0
      then (!stack_slot_lbl, num_stack_slots.(1) * 8 + n * 8)
      else (!stack_slot_lbl, n * 8)
  | Incoming n -> ((if has_stack_frame() then !stack_size_lbl else 0), 48 + n)
  | Outgoing n -> (0,  n)

(* Output a symbol *)

let emit_symbol =
  match Config.system with
  | "elf" | "bsd" -> (fun s -> Emitaux.emit_symbol '.' s)
  | "rhapsody"    -> (fun s -> emit_char '_'; Emitaux.emit_symbol '$' s)
  | _ -> assert false

(* Output a label *)

let label_prefix =
  match Config.system with
  | "elf" | "bsd" -> ".L"
  | "rhapsody" -> "L"
  | _ -> assert false

let emit_label lbl =
  emit_string label_prefix; emit_int lbl

(* Section switching *)

let toc_space =
  match Config.system with
  | "elf" | "bsd" -> " .section \".toc\",\"aw\"\n"
  | "rhapsody"    -> " .toc\n"
  | _ -> assert false

let data_space =
  match Config.system with
  | "elf" | "bsd" -> " .section \".data\"\n"
  | "rhapsody"    -> " .data\n"
  | _ -> assert false

let code_space =
  match Config.system with
  | "elf" | "bsd" -> " .section \".text\"\n"
  | "rhapsody"    -> " .text\n"
  | _ -> assert false

let rodata_space =
  match Config.system with
  | "elf" | "bsd" -> " .section \".rodata\"\n"
  | "rhapsody"    -> " .const\n"
  | _ -> assert false

(* Output a pseudo-register *)

let emit_reg r =
  match r.loc with
    Reg r -> emit_string (register_name r)
  | _ -> fatal_error "Emit.emit_reg"

let use_full_regnames = 
  Config.system = "rhapsody"

let emit_gpr r =
  if use_full_regnames then emit_char 'r';
  emit_int r

let emit_fpr r =
  if use_full_regnames then emit_char 'f';
  emit_int r

let emit_ccr r =
  if use_full_regnames then emit_string "cr";
  emit_int r

(* Output a stack reference *)

let emit_stack r =
  match r.loc with
    Stack s ->
      let lbl, ofs = slot_offset s (register_class r) in
        if lbl > 0 then
         `{emit_label lbl}+`;
       `{emit_int ofs}({emit_gpr 1})`
  | _ -> fatal_error "Emit.emit_stack"

(* Split a 32-bit integer constants in two 16-bit halves *)

let low n = n land 0xFFFF
let high n = n asr 16

let nativelow n = Nativeint.to_int n land 0xFFFF
let nativehigh n = Nativeint.to_int (Nativeint.shift_right n 16)

let is_immediate n =
  n <= 32767 && n >= -32768

let is_native_immediate n =
  n <= 32767n && n >= -32768n


type tocentry =
    TocSymOfs of (string * int)
  | TocLabel of int
  | TocInt of nativeint
  | TocFloat of string

(* List of all labels in tocref (reverse order) *)
let tocref_entries = ref []

(* Output a TOC reference *)

let emit_symbol_offset (s, d) =
  emit_symbol s;
  if d > 0 then `+`;
  if d <> 0 then emit_int d

let emit_tocentry entry = 
  match entry with
      TocSymOfs(s,d) -> emit_symbol_offset(s,d)
    | TocInt i -> emit_nativeint i
    | TocFloat f -> emit_string f
    | TocLabel lbl -> emit_label lbl

 let rec tocref_label = function
    ( [] , content ) ->
      let lbl = new_label() in
       tocref_entries := (lbl, content) :: !tocref_entries;
       lbl
    | ( (lbl, o_content) :: lst, content) ->
      if content = o_content then
         lbl
      else
         tocref_label (lst,  content)

let emit_tocref entry = 
    let lbl = tocref_label (!tocref_entries,entry) in
      emit_label lbl; emit_string "@toc(2) #"; emit_tocentry entry


(* Output a load or store operation *)

let valid_offset instr ofs =
  ofs land 3 = 0 || (instr <> "ld" && instr <> "std")

let emit_load_store instr addressing_mode addr n arg =
  match addressing_mode with
    Ibased(s, d) ->
      let dd = (d + 0x8000) in (* We can only offset by -0x8000 .. +0x7fff *)
      let a = (dd land -0x10000) in
      let b = (dd land 0xffff) - 0x8000 in
        `      ld      {emit_gpr 11}, {emit_tocref (TocSymOfs (s,a))}\n`;
        `      {emit_string instr}     {emit_reg arg}, {emit_int b}({emit_gpr 11})\n`
  | Iindexed ofs ->
      if is_immediate ofs && valid_offset instr ofs then
        `      {emit_string instr}     {emit_reg arg}, {emit_int ofs}({emit_reg addr.(n)})\n`
      else begin
        `      lis     {emit_gpr 0}, {emit_int(high ofs)}\n`;
        if low ofs <> 0 then
          `    ori     {emit_gpr 0}, {emit_gpr 0}, {emit_int(low ofs)}\n`;
        `      {emit_string instr}x    {emit_reg arg}, {emit_reg addr.(n)}, {emit_gpr 0}\n`
      end
  | Iindexed2 ->
      `        {emit_string instr}x    {emit_reg arg}, {emit_reg addr.(n)}, {emit_reg addr.(n+1)}\n`

(* After a comparison, extract the result as 0 or 1 *)

let emit_set_comp cmp res =
  `    mfcr    {emit_gpr 0}\n`;
  let bitnum =
    match cmp with
      Ceq | Cne -> 2
    | Cgt | Cle -> 1
    | Clt | Cge -> 0 in
`      rlwinm  {emit_reg res}, {emit_gpr 0}, {emit_int(bitnum+1)}, 31, 31\n`;
  begin match cmp with
    Cne | Cle | Cge -> `       xori    {emit_reg res}, {emit_reg res}, 1\n`
  | _ -> ()
  end

(* Record live pointers at call points *)

type frame_descr =
  { fd_lbl: int;                        (* Return address *)
    fd_frame_size_lbl: int;                 (* Size of stack frame *)
    fd_live_offset: (int * int) list }          (* Offsets/regs of live addresses *)

let frame_descriptors = ref([] : frame_descr list)

let record_frame live =
  let lbl = new_label() in
  let live_offset = ref [] in
  Reg.Set.iter
    (function
        {typ = Addr; loc = Reg r} ->
          live_offset := (0, (r lsl 1) + 1) :: !live_offset
      | {typ = Addr; loc = Stack s} as reg ->
          live_offset := slot_offset s (register_class reg) :: !live_offset
      | _ -> ())
    live;
  frame_descriptors :=
    { fd_lbl = lbl;
      fd_frame_size_lbl = !stack_size_lbl; (* frame_size *)
      fd_live_offset = !live_offset } :: !frame_descriptors;
  `{emit_label lbl}:\n`

let emit_frame fd =
  `    .quad   {emit_label fd.fd_lbl} + 4\n`;
  `    .short  {emit_label fd.fd_frame_size_lbl}\n`;
  `    .short  {emit_int (List.length fd.fd_live_offset)}\n`;
  List.iter
    (fun (lbl,n) ->
      `        .short  `;
      if lbl > 0 then `{emit_label lbl}+`;
      `{emit_int n}\n`)
    fd.fd_live_offset;
  `    .align  3\n`

(* Record external C functions to be called in a position-independent way
   (for MacOSX) *)

let pic_externals = (Config.system = "rhapsody")

let external_functions = ref StringSet.empty

let emit_external s =
  `    .non_lazy_symbol_pointer\n`;
  `L{emit_symbol s}$non_lazy_ptr:\n`;
  `    .indirect_symbol {emit_symbol s}\n`;
  `    .quad   0\n`

(* Names for conditional branches after comparisons *)

let branch_for_comparison = function
    Ceq -> "beq" | Cne -> "bne"
  | Cle -> "ble" | Cgt -> "bgt"
  | Cge -> "bge" | Clt -> "blt"

let name_for_int_comparison = function
    Isigned cmp -> ("cmpd", branch_for_comparison cmp)
  | Iunsigned cmp -> ("cmpld", branch_for_comparison cmp)

(* Names for various instructions *)

let name_for_intop = function
    Iadd -> "add"
  | Imul -> "mulld"
  | Idiv -> "divd"
  | Iand -> "and"
  | Ior  -> "or"
  | Ixor -> "xor"
  | Ilsl -> "sld"
  | Ilsr -> "srd"
  | Iasr -> "srad"
  | _ -> Misc.fatal_error "Emit.Intop"

let name_for_intop_imm = function
    Iadd -> "addi"
  | Imul -> "mulli"
  | Iand -> "andi."
  | Ior  -> "ori"
  | Ixor -> "xori"
  | Ilsl -> "sldi"
  | Ilsr -> "srdi"
  | Iasr -> "sradi"
  | _ -> Misc.fatal_error "Emit.Intop_imm"

let name_for_floatop1 = function
    Inegf -> "fneg"
  | Iabsf -> "fabs"
  | _ -> Misc.fatal_error "Emit.Iopf1"

let name_for_floatop2 = function
    Iaddf -> "fadd"
  | Isubf -> "fsub"
  | Imulf -> "fmul"
  | Idivf -> "fdiv"
  | _ -> Misc.fatal_error "Emit.Iopf2"

let name_for_specific = function
    Imultaddf -> "fmadd"
  | Imultsubf -> "fmsub"
  | _ -> Misc.fatal_error "Emit.Ispecific"

(* Name of current function *)
let function_name = ref ""
(* Entry point for tail recursive calls *)
let tailrec_entry_point = ref 0
(* Names of functions defined in the current file *)
let defined_functions = ref StringSet.empty
(* Label of glue code for calling the GC *)
let call_gc_label = ref 0
(* Label of jump table *)
let lbl_jumptbl = ref 0
(* List of all labels in jumptable (reverse order) *)
let jumptbl_entries = ref []
(* Number of jumptable entries *)
let num_jumptbl_entries = ref 0

(* Fixup conditional branches that exceed hardware allowed range *)

let load_store_size = function
    Ibased(s, d) -> 2
  | Iindexed ofs -> if is_immediate ofs then 1 else 3
  | Iindexed2 -> 1

let instr_size = function
    Lend -> 0
  | Lop(Imove | Ispill | Ireload) -> 1
  | Lop(Iconst_int n) -> if is_native_immediate n then 1 else 2
  | Lop(Iconst_float s) -> 2
  | Lop(Iconst_symbol s) -> 2
  | Lop(Icall_ind) -> 6
  | Lop(Icall_imm s) -> 7
  | Lop(Itailcall_ind) -> if !contains_calls then 7 else if has_stack_frame() then 5 else 4
  | Lop(Itailcall_imm s) -> if s = !function_name then 1 else 
                            if !contains_calls then 8 else
                           if has_stack_frame() then 6 else 5
  | Lop(Iextcall(s, true)) -> 8
  | Lop(Iextcall(s, false)) -> 7
  | Lop(Istackoffset n) -> 0
  | Lop(Iload(chunk, addr)) ->
      if chunk = Byte_signed
      then load_store_size addr + 1
      else load_store_size addr
  | Lop(Istore(chunk, addr)) -> load_store_size addr
  | Lop(Ialloc n) -> 4
  | Lop(Ispecific(Ialloc_far n)) -> 5
  | Lop(Iintop Imod) -> 3
  | Lop(Iintop(Icomp cmp)) -> 4
  | Lop(Iintop op) -> 1
  | Lop(Iintop_imm(Idiv, n)) -> 2
  | Lop(Iintop_imm(Imod, n)) -> 4
  | Lop(Iintop_imm(Icomp cmp, n)) -> 4
  | Lop(Iintop_imm(op, n)) -> 1
  | Lop(Inegf | Iabsf | Iaddf | Isubf | Imulf | Idivf) -> 1
  | Lop(Ifloatofint) -> 3
  | Lop(Iintoffloat) -> 3
  | Lop(Ispecific sop) -> 1
  | Lreloadretaddr -> 2
  | Lreturn -> if has_stack_frame() then 2 else 1
  | Llabel lbl -> 0
  | Lbranch lbl -> 1
  | Lcondbranch(tst, lbl) -> 2
  | Lcondbranch3(lbl0, lbl1, lbl2) ->
      1 + (if lbl0 = None then 0 else 1)
        + (if lbl1 = None then 0 else 1)
        + (if lbl2 = None then 0 else 1)
  | Lswitch jumptbl -> 7
  | Lsetuptrap lbl -> 1
  | Lpushtrap -> 7
  | Lpoptrap -> 1
  | Lraise -> 6

let label_map code =
  let map = Hashtbl.create 37 in
  let rec fill_map pc instr =
    match instr.desc with
      Lend -> (pc, map)
    | Llabel lbl -> Hashtbl.add map lbl pc; fill_map pc instr.next
    | op -> fill_map (pc + instr_size op) instr.next
  in fill_map 0 code

let max_branch_offset = 8180
(* 14-bit signed offset in words.  Remember to cut some slack
   for multi-word instructions where the branch can be anywhere in
   the middle.  12 words of slack is plenty. *)

let branch_overflows map pc_branch lbl_dest =
  let pc_dest = Hashtbl.find map lbl_dest in
  let delta = pc_dest - (pc_branch + 1) in
  delta <= -max_branch_offset || delta >= max_branch_offset

let opt_branch_overflows map pc_branch opt_lbl_dest =
  match opt_lbl_dest with
    None -> false
  | Some lbl_dest -> branch_overflows map pc_branch lbl_dest

let fixup_branches codesize map code =
  let expand_optbranch lbl n arg next =
    match lbl with
      None -> next
    | Some l ->
        instr_cons (Lcondbranch(Iinttest_imm(Isigned Ceq, n), l))
                   arg [||] next in
  let rec fixup did_fix pc instr =
    match instr.desc with
      Lend -> did_fix
    | Lcondbranch(test, lbl) when branch_overflows map pc lbl ->
        let lbl2 = new_label() in
        let cont =
          instr_cons (Lbranch lbl) [||] [||]
            (instr_cons (Llabel lbl2) [||] [||] instr.next) in
        instr.desc <- Lcondbranch(invert_test test, lbl2);
        instr.next <- cont;
        fixup true (pc + 2) instr.next
    | Lcondbranch3(lbl0, lbl1, lbl2)
      when opt_branch_overflows map pc lbl0
        || opt_branch_overflows map pc lbl1
        || opt_branch_overflows map pc lbl2 ->
        let cont =
          expand_optbranch lbl0 0 instr.arg
            (expand_optbranch lbl1 1 instr.arg
              (expand_optbranch lbl2 2 instr.arg instr.next)) in
        instr.desc <- cont.desc;
        instr.next <- cont.next;
        fixup true pc instr
    | Lop(Ialloc n) when codesize - pc >= max_branch_offset ->
        instr.desc <- Lop(Ispecific(Ialloc_far n));
        fixup true (pc + 4) instr.next
    | op ->
        fixup did_fix (pc + instr_size op) instr.next
  in fixup false 0 code

(* Iterate branch expansion till all conditional branches are OK *)

let rec branch_normalization code =
  let (codesize, map) = label_map code in
  if codesize >= max_branch_offset && fixup_branches codesize map code
  then branch_normalization code
  else ()


(* Output the assembly code for an instruction *)

let rec emit_instr i dslot =
    match i.desc with
      Lend -> ()
    | Lop(Imove | Ispill | Ireload) ->
        let src = i.arg.(0) and dst = i.res.(0) in
        if src.loc <> dst.loc then begin
           match (src, dst) with
              {loc = Reg rs; typ = (Int | Addr)}, {loc = Reg rd} ->
                `      mr      {emit_reg dst}, {emit_reg src}\n`
            | {loc = Reg rs; typ = Float}, {loc = Reg rd; typ = Float} ->
                `      fmr     {emit_reg dst}, {emit_reg src}\n`
            | {loc = Reg rs; typ = (Int | Addr)}, {loc = Stack sd} ->
                `      std     {emit_reg src}, {emit_stack dst}\n`
            | {loc = Reg rs; typ = Float}, {loc = Stack sd} ->
                `      stfd    {emit_reg src}, {emit_stack dst}\n`
            | {loc = Stack ss; typ = (Int | Addr)}, {loc = Reg rd} ->
                `      ld      {emit_reg dst}, {emit_stack src}\n`
            | {loc = Stack ss; typ = Float}, {loc = Reg rd} ->
                `      lfd     {emit_reg dst}, {emit_stack src}\n`
            | (_, _) ->
                fatal_error "Emit: Imove"
        end
    | Lop(Iconst_int n) ->
        if is_native_immediate n then
          `    li      {emit_reg i.res.(0)}, {emit_nativeint n}\n`
        else if n >= -0x8000_0000n && n <= 0x7FFF_FFFFn then begin
          `    lis     {emit_reg i.res.(0)}, {emit_int(nativehigh n)}\n`;
          if nativelow n <> 0 then
            `  ori     {emit_reg i.res.(0)}, {emit_reg i.res.(0)}, {emit_int(nativelow n)}\n`
        end else begin
           `   ld      {emit_reg i.res.(0)}, {emit_tocref (TocInt n)}\n`
        end
    | Lop(Iconst_float s) ->
        `      lfd     {emit_reg i.res.(0)}, {emit_tocref (TocFloat s)}\n`
    | Lop(Iconst_symbol s) ->
        `      ld      {emit_reg i.res.(0)}, {emit_tocref (TocSymOfs (s,0))}\n`
    | Lop(Icall_ind) ->
        `      std     {emit_gpr 2},40({emit_gpr 1})\n`;
        `      ld      {emit_gpr 2}, 8({emit_reg i.arg.(0)})\n`;
        `      ld      {emit_reg i.arg.(0)}, 0({emit_reg i.arg.(0)})\n`;
        `      mtctr   {emit_reg i.arg.(0)}\n`;
        record_frame i.live;
        `      bctrl\n`;
        `      ld     {emit_gpr 2},40({emit_gpr 1})\n`
    | Lop(Icall_imm s) ->
       `       ld      {emit_gpr 11}, {emit_tocref (TocSymOfs (s,0))}\n`;
        `      std     {emit_gpr 2},40({emit_gpr 1})\n`;
       `       ld      {emit_gpr 2}, 8({emit_gpr 11})\n`;
       `       ld      {emit_gpr 11}, 0({emit_gpr 11})\n`;
       `       mtctr   {emit_gpr 11}\n`;
        record_frame i.live;   
        `      bctrl\n`;
        `      ld     {emit_gpr 2},40({emit_gpr 1})\n`
    | Lop(Itailcall_ind) ->
         `     ld      {emit_gpr 2}, 8({emit_reg i.arg.(0)})\n`;
         `     ld      {emit_reg i.arg.(0)}, 0({emit_reg i.arg.(0)})\n`;
          `    mtctr   {emit_reg i.arg.(0)}\n`;
        if has_stack_frame() then
          `    ld      {emit_gpr 1}, 0({emit_gpr 1})\n`;
        if !contains_calls then begin
          `    ld      {emit_gpr 11}, 16({emit_gpr 1})\n`;
          `    mtlr    {emit_gpr 11}\n`
        end;
        `      bctr\n`
    | Lop(Itailcall_imm s) ->
        if s = !function_name then
          `    b       {emit_label !tailrec_entry_point}\n`
        else begin
          if has_stack_frame() then
            `  ld      {emit_gpr 1}, 0({emit_gpr 1})\n`;
          if !contains_calls then begin
            `  ld      {emit_gpr 11}, 16({emit_gpr 1})\n`;
            `  mtlr    {emit_gpr 11}\n`
          end;
          `    ld      {emit_gpr 11}, {emit_tocref (TocSymOfs (s,0))}\n`;
         `     ld      {emit_gpr 2}, 8({emit_gpr 11})\n`;
         `     ld      {emit_gpr 11}, 0({emit_gpr 11})\n`;
         `     mtctr   {emit_gpr 11}\n`;
          `    bctr\n`
        end
    | Lop(Iextcall(s, alloc)) ->
        if alloc then begin
          `    ld      {emit_gpr 11}, {emit_tocref (TocSymOfs (s,0))}\n`;
          `    ld      {emit_gpr 12}, {emit_tocref (TocSymOfs ("caml_c_call",0))}\n`;
        end else
          `    ld      {emit_gpr 12}, {emit_tocref (TocSymOfs (s,0))}\n`;
        `      std     {emit_gpr 2}, 40({emit_gpr 1})\n`;
       `       ld      {emit_gpr 2}, 8({emit_gpr 12})\n`;
       `       ld      {emit_gpr 12}, 0({emit_gpr 12})\n`;
        `      mtctr   {emit_gpr 12}\n`;
        if alloc then record_frame i.live;
        `      bctrl\n`;
        `      ld      {emit_gpr 2}, 40({emit_gpr 1})\n`
    | Lop(Istackoffset n) ->
       if n > !stack_args_size then
         stack_args_size := n
    | Lop(Iload(chunk, addr)) ->
        let loadinstr =
          match chunk with
            Byte_unsigned -> "lbz"
          | Byte_signed -> "lbz"
          | Sixteen_unsigned -> "lhz"
          | Sixteen_signed -> "lha"
          | Thirtytwo_unsigned -> "lwz"
          | Thirtytwo_signed -> "lwa"
          | Word -> "ld"
          | Single -> "lfs"
          | Double | Double_u -> "lfd" in
        emit_load_store loadinstr addr i.arg 0 i.res.(0);
        if chunk = Byte_signed then
          `    extsb   {emit_reg i.res.(0)}, {emit_reg i.res.(0)}\n`
    | Lop(Istore(chunk, addr)) ->
        let storeinstr =
          match chunk with
            Byte_unsigned | Byte_signed -> "stb"
          | Sixteen_unsigned | Sixteen_signed -> "sth"
          | Thirtytwo_unsigned | Thirtytwo_signed -> "stw"
          | Word -> "std"
          | Single -> "stfs"
          | Double | Double_u -> "stfd" in
        emit_load_store storeinstr addr i.arg 1 i.arg.(0)
    | Lop(Ialloc n) ->
        if !call_gc_label = 0 then call_gc_label := new_label();
        `      addi    {emit_gpr 31}, {emit_gpr 31}, {emit_int(-n)}\n`;
        `      cmpld   {emit_gpr 31}, {emit_gpr 30}\n`;
        `      addi    {emit_reg i.res.(0)}, {emit_gpr 31}, 8\n`;
        record_frame i.live;
        `      bltl    {emit_label !call_gc_label}\n` (* Must be 4 insns to restart *)
    | Lop(Ispecific(Ialloc_far n)) ->
        if !call_gc_label = 0 then call_gc_label := new_label();
        let lbl = new_label() in
        `      addi    {emit_gpr 31}, {emit_gpr 31}, {emit_int(-n)}\n`;
        `      cmpld   {emit_gpr 31}, {emit_gpr 30}\n`;
        `      bge     {emit_label lbl}\n`;
        record_frame i.live;
        `      bl      {emit_label !call_gc_label}\n`; (* Must be 4 insns to restart *)
        `{emit_label lbl}:     addi    {emit_reg i.res.(0)}, {emit_gpr 31}, {emit_int size_addr}\n`
    | Lop(Iintop Isub) ->               (* subfc has swapped arguments *)
        `      subfc   {emit_reg i.res.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(0)}\n`
    | Lop(Iintop Imod) ->
        `      divd    {emit_gpr 0}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
        `      mulld   {emit_gpr 0}, {emit_gpr 0}, {emit_reg i.arg.(1)}\n`;
        `      subfc   {emit_reg i.res.(0)}, {emit_gpr 0}, {emit_reg i.arg.(0)}\n`
    | Lop(Iintop(Icomp cmp)) ->
        begin match cmp with
          Isigned c ->
            `  cmpd    {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
            emit_set_comp c i.res.(0)
        | Iunsigned c ->
            `  cmpld   {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
            emit_set_comp c i.res.(0)
        end
    | Lop(Iintop Icheckbound) ->
        `      tdlle   {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`
    | Lop(Iintop op) ->
        let instr = name_for_intop op in
        `      {emit_string instr}     {emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`
    | Lop(Iintop_imm(Isub, n)) ->
        `      addi    {emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_int(-n)}\n`
    | Lop(Iintop_imm(Idiv, n)) ->       (* n is guaranteed to be a power of 2 *)
        let l = Misc.log2 n in
        `      sradi   {emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_int l}\n`;
        `      addze   {emit_reg i.res.(0)}, {emit_reg i.res.(0)}\n` 
    | Lop(Iintop_imm(Imod, n)) ->       (* n is guaranteed to be a power of 2 *)
        let l = Misc.log2 n in
        `      sradi   {emit_gpr 0}, {emit_reg i.arg.(0)}, {emit_int l}\n`;
        `      addze   {emit_gpr 0}, {emit_gpr 0}\n`;
        `      sldi    {emit_gpr 0}, {emit_gpr 0}, {emit_int l}\n`;
        `      subfc   {emit_reg i.res.(0)}, {emit_gpr 0}, {emit_reg i.arg.(0)}\n` 
    | Lop(Iintop_imm(Icomp cmp, n)) ->
        begin match cmp with
          Isigned c ->
            `  cmpdi   {emit_reg i.arg.(0)}, {emit_int n}\n`;
            emit_set_comp c i.res.(0)
        | Iunsigned c ->
            `  cmpldi  {emit_reg i.arg.(0)}, {emit_int n}\n`;
            emit_set_comp c i.res.(0)
        end
    | Lop(Iintop_imm(Icheckbound, n)) ->
        `      tdllei   {emit_reg i.arg.(0)}, {emit_int n}\n`
    | Lop(Iintop_imm(op, n)) ->
        let instr = name_for_intop_imm op in
        `      {emit_string instr}     {emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_int n}\n`
    | Lop(Inegf | Iabsf as op) ->
        let instr = name_for_floatop1 op in
        `      {emit_string instr}     {emit_reg i.res.(0)}, {emit_reg i.arg.(0)}\n`
    | Lop(Iaddf | Isubf | Imulf | Idivf as op) ->
        let instr = name_for_floatop2 op in
        `      {emit_string instr}     {emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`
    | Lop(Ifloatofint) ->
       let ofs = if has_stack_frame() then 16 else 8 * (2 + num_stack_slots.(0) + num_stack_slots.(1)) in
          `    std     {emit_reg i.arg.(0)}, -{emit_int ofs}({emit_gpr 1})\n`;
          `    lfd     {emit_reg i.res.(0)}, -{emit_int ofs}({emit_gpr 1})\n`;
          `    fcfid   {emit_reg i.res.(0)}, {emit_reg i.res.(0)}\n`
    | Lop(Iintoffloat) ->
       let ofs = if has_stack_frame() then 16 else 8 * (2 + num_stack_slots.(0) + num_stack_slots.(1)) in
          `    fctidz  {emit_fpr 0}, {emit_reg i.arg.(0)}\n`;
          `    stfd    {emit_fpr 0}, -{emit_int ofs}({emit_gpr 1})\n`;
          `    ld      {emit_reg i.res.(0)}, -{emit_int ofs}({emit_gpr 1})\n`
    | Lop(Ispecific sop) ->
        let instr = name_for_specific sop in
        `      {emit_string instr}     {emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}\n`
    | Lreloadretaddr ->
       if has_stack_frame() then begin
          `    ld      {emit_gpr 11}, {emit_label !stack_size_lbl}+16({emit_gpr 1})\n`;
          `    mtlr    {emit_gpr 11}\n`
        end
    | Lreturn ->
       if has_stack_frame() then                                                             
         `     ld      {emit_gpr 1}, 0({emit_gpr 1})\n`;
        `      blr\n`
    | Llabel lbl ->
        `{emit_label lbl}:\n`
    | Lbranch lbl ->
        `      b       {emit_label lbl}\n`
    | Lcondbranch(tst, lbl) ->
        begin match tst with
          Itruetest ->
            `  cmpdi   {emit_reg i.arg.(0)}, 0\n`;
            emit_delay dslot;
            `  bne     {emit_label lbl}\n`
        | Ifalsetest ->
            `  cmpdi   {emit_reg i.arg.(0)}, 0\n`;
            emit_delay dslot;
            `  beq     {emit_label lbl}\n`
        | Iinttest cmp ->
            let (comp, branch) = name_for_int_comparison cmp in
            `  {emit_string comp}      {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
            emit_delay dslot;
            `  {emit_string branch}    {emit_label lbl}\n`
        | Iinttest_imm(cmp, n) ->
            let (comp, branch) = name_for_int_comparison cmp in
            `  {emit_string comp}i     {emit_reg i.arg.(0)}, {emit_int n}\n`;
            emit_delay dslot;
            `  {emit_string branch}    {emit_label lbl}\n`
        | Ifloattest(cmp, neg) ->
            `  fcmpu   {emit_ccr 0}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
            (* bit 0 = lt, bit 1 = gt, bit 2 = eq *)
            let (bitnum, negtst) =
              match cmp with
                Ceq -> (2, neg)
              | Cne -> (2, not neg)
              | Cle -> `       cror    3, 0, 2\n`; (* lt or eq *)
                       (3, neg)
              | Cgt -> (1, neg)
              | Cge -> `       cror    3, 1, 2\n`; (* gt or eq *)
                       (3, neg)
              | Clt -> (0, neg) in
            emit_delay dslot;
            if negtst
            then `     bf      {emit_int bitnum}, {emit_label lbl}\n`
            else `     bt      {emit_int bitnum}, {emit_label lbl}\n`
        | Ioddtest ->
            `  andi.   {emit_gpr 0}, {emit_reg i.arg.(0)}, 1\n`;
            emit_delay dslot;
            `  bne     {emit_label lbl}\n`
        | Ieventest ->
            `  andi.   {emit_gpr 0}, {emit_reg i.arg.(0)}, 1\n`;
            emit_delay dslot;
            `  beq     {emit_label lbl}\n`
        end
    | Lcondbranch3(lbl0, lbl1, lbl2) ->
        `      cmpdi   {emit_reg i.arg.(0)}, 1\n`;
        emit_delay dslot;
        begin match lbl0 with
          None -> ()
        | Some lbl -> `        blt     {emit_label lbl}\n`
        end;
        begin match lbl1 with
          None -> ()
        | Some lbl -> `        beq     {emit_label lbl}\n`
        end;
        begin match lbl2 with
          None -> ()
        | Some lbl -> `        bgt     {emit_label lbl}\n`
        end
    | Lswitch jumptbl ->
        if !lbl_jumptbl = 0 then lbl_jumptbl := new_label();
        `      ld      {emit_gpr 11}, {emit_tocref (TocLabel !lbl_jumptbl)}\n`;
        `      addi    {emit_gpr 0}, {emit_reg i.arg.(0)}, {emit_int !num_jumptbl_entries}\n`;
        `      sldi    {emit_gpr 0}, {emit_gpr 0}, 2\n`;
        `      lwax    {emit_gpr 0}, {emit_gpr 11}, {emit_gpr 0}\n`;
        `      add     {emit_gpr 0}, {emit_gpr 11}, {emit_gpr 0}\n`;
        `      mtctr   {emit_gpr 0}\n`;
        `      bctr\n`;
        for i = 0 to Array.length jumptbl - 1 do
          jumptbl_entries := jumptbl.(i) :: !jumptbl_entries;
          incr num_jumptbl_entries
        done
    | Lsetuptrap lbl ->
        `      bl      {emit_label lbl}\n`;
    | Lpushtrap ->
       stack_traps_size := !stack_traps_size + 32;
       `       addi    {emit_gpr 11}, {emit_gpr 1}, {emit_label !stack_size_lbl}-{emit_int !stack_traps_size}\n`;
        `      mflr    {emit_gpr 0}\n`;
       `       std     {emit_gpr 29}, 0({emit_gpr 11})\n`;
       `       std     {emit_gpr 0}, 8({emit_gpr 11})\n`;
       `       std     {emit_gpr 1}, 16({emit_gpr 11})\n`;
       `       std     {emit_gpr 2}, 24({emit_gpr 11})\n`;
       `       mr      {emit_gpr 29}, {emit_gpr 11}\n`
    | Lpoptrap ->
        `      ld      {emit_gpr 29}, 0({emit_gpr 29})\n`
    | Lraise ->
        `      ld      {emit_gpr 0}, 8({emit_gpr 29})\n`;
        `      ld      {emit_gpr 1}, 16({emit_gpr 29})\n`;
        `      ld      {emit_gpr 2}, 24({emit_gpr 29})\n`;
        `      mtlr    {emit_gpr 0}\n`;
        `      ld      {emit_gpr 29}, 0({emit_gpr 29})\n`;
        `      blr\n`

and emit_delay = function
    None -> ()
  | Some i -> emit_instr i None

(* Checks if a pseudo-instruction expands to instructions
   that do not branch and do not affect CR0 nor R12. *)

let is_simple_instr i =
  match i.desc with
    Lop op ->
      begin match op with
        Icall_imm _ | Icall_ind | Itailcall_imm _ | Itailcall_ind |
        Iextcall(_, _) -> false
      | Ialloc(_) -> false
      | Iintop(Icomp _) -> false
      | Iintop_imm(Iand, _) -> false
      | Iintop_imm(Icomp _, _) -> false
      | _ -> true
      end
  | Lreloadretaddr -> true
  | _ -> false

let no_interference res arg =
  try
    for i = 0 to Array.length arg - 1 do
      for j = 0 to Array.length res - 1 do
        if arg.(i).loc = res.(j).loc then raise Exit
      done
    done;
    true
  with Exit ->
    false

(* Emit a sequence of instructions, trying to fill delay slots for branches *)

let rec emit_all i =
  match i with
    {desc = Lend} -> ()
  | {next = {desc = (Lcondbranch(_, _) | Lcondbranch3(_, _, _))}}
    when is_simple_instr i & no_interference i.res i.next.arg ->
      emit_instr i.next (Some i);
      emit_all i.next.next
  | _ ->
      emit_instr i None;
      emit_all i.next

(* Emission of a function declaration *)

let fundecl fundecl =
  function_name := fundecl.fun_name;
  defined_functions := StringSet.add fundecl.fun_name !defined_functions;
  tailrec_entry_point := new_label();
  if has_stack_frame() then
    stack_size_lbl := new_label();
  stack_slot_lbl := new_label();
  stack_args_size := 0;
  stack_traps_size := 0;
  call_gc_label := 0;
  `    .globl  {emit_symbol fundecl.fun_name}\n`;
  begin match Config.system with
  | "elf" | "bsd" ->
      `        .section \".opd\",\"aw\"\n`;
      `        .align 3\n`;
      `        .type   {emit_symbol fundecl.fun_name}, @function\n`;
      `{emit_symbol fundecl.fun_name}:\n`;
      `        .quad .L.{emit_symbol fundecl.fun_name},.TOC.@tocbase\n`;
      `        .previous\n`;
      `        .align  2\n`;
      emit_string code_space;
      `.L.{emit_symbol fundecl.fun_name}:\n`
  | _ ->
      `        .align  2\n`;
      emit_string code_space;
      `{emit_symbol fundecl.fun_name}:\n`
  end;
  if !contains_calls then begin
    `  mflr    {emit_gpr 0}\n`;
    `  std     {emit_gpr 0}, 16({emit_gpr 1})\n`
  end;
  if has_stack_frame() then
    `  stdu    {emit_gpr 1}, -{emit_label !stack_size_lbl}({emit_gpr 1})\n`;
  `{emit_label !tailrec_entry_point}:\n`;
  branch_normalization fundecl.fun_body;
  emit_all fundecl.fun_body;
  `    .size .L.{emit_symbol fundecl.fun_name}, . - .L.{emit_symbol fundecl.fun_name}\n`;
  if has_stack_frame() then begin
    ` .set {emit_label !stack_size_lbl},{emit_int (frame_size_sans_args() + !stack_args_size + !stack_traps_size)}  # stack size including traps\n`;
    ` .set {emit_label !stack_slot_lbl},{emit_int (48 + !stack_args_size)}  # stack slot offset\n`
  end else (* leave 8 bytes for float <-> conversions *)
    ` .set {emit_label !stack_slot_lbl},{emit_int (40-frame_size_sans_args())} # stack slot offset (negative)\n`;
                                                                       
  (* Emit the glue code to call the GC *)
  if !call_gc_label > 0 then begin
    `{emit_label !call_gc_label}:\n`;
    `  ld      {emit_gpr 12}, {emit_tocref (TocSymOfs ("caml_call_gc",0))}\n`;
    `  ld      {emit_gpr 12}, 0({emit_gpr 12})\n`;
    `  mtctr   {emit_gpr 12}\n`;
    `  bctr\n`;
  end

(* Emission of data *)

let declare_global_data s =
  `    .globl  {emit_symbol s}\n`;
  if Config.system = "elf" || Config.system = "bsd" then
    `  .type   {emit_symbol s}, @object\n`

let emit_item = function
    Cglobal_symbol s ->
      declare_global_data s
  | Cdefine_symbol s ->
      `{emit_symbol s}:\n`;
  | Cdefine_label lbl ->
      `{emit_label (lbl + 100000)}:\n`
  | Cint8 n ->
      `        .byte   {emit_int n}\n`
  | Cint16 n ->
      `        .short  {emit_int n}\n`
  | Cint32 n ->
      `        .long   {emit_nativeint n}\n`
  | Cint n ->
      `        .quad   {emit_nativeint n}\n`
  | Csingle f ->
      `        .float  0d{emit_string f}\n`
  | Cdouble f ->
      `        .double 0d{emit_string f}\n`
  | Csymbol_address s ->
      `        .quad   {emit_symbol s}\n`
  | Clabel_address lbl ->
      `        .quad   {emit_label (lbl + 100000)}\n`
  | Cstring s ->
      emit_bytes_directive "   .byte   " s
  | Cskip n ->
      if n > 0 then `  .space  {emit_int n}\n`
  | Calign n ->
      `        .align  {emit_int (Misc.log2 n)}\n`

let data l =
  emit_string data_space;
  List.iter emit_item l

(* Beginning / end of an assembly file *)

let begin_assembly() =
  defined_functions := StringSet.empty;
  external_functions := StringSet.empty;
  tocref_entries := [];
  num_jumptbl_entries := 0;
  jumptbl_entries := [];
  lbl_jumptbl := 0;
  (* Emit the beginning of the segments *)
  let lbl_begin = Compilenv.make_symbol (Some "data_begin") in
  emit_string data_space;
  declare_global_data lbl_begin;
  `{emit_symbol lbl_begin}:\n`;
  let lbl_begin = Compilenv.make_symbol (Some "code_begin") in
  emit_string code_space;
  declare_global_data lbl_begin;
  `{emit_symbol lbl_begin}:\n`

let end_assembly() =
  (* Emit the jump table *)
  if !num_jumptbl_entries > 0 then begin
    emit_string code_space;
    `{emit_label !lbl_jumptbl}:\n`;
    List.iter
      (fun lbl -> `    .long   {emit_label lbl} - {emit_label !lbl_jumptbl}\n`)
      (List.rev !jumptbl_entries);
    jumptbl_entries := []
  end;
  if !tocref_entries <> [] then begin
    emit_string toc_space;
    List.iter
      (fun (lbl, entry) ->
        `{emit_label lbl}:\n`;
       match entry with
        TocFloat f ->
         `     .double {emit_tocentry entry}\n`
       | _ -> 
          `    .tc     {emit_label lbl}[TC],{emit_tocentry entry}\n`
      )
      !tocref_entries;
      tocref_entries := []
  end;
  if pic_externals then
    (* Emit the pointers to external functions *)
    StringSet.iter emit_external !external_functions;
  (* Emit the end of the segments *)
  emit_string code_space;
  let lbl_end = Compilenv.make_symbol (Some "code_end") in
  declare_global_data lbl_end;
  `{emit_symbol lbl_end}:\n`;
  `    .long   0\n`;
  emit_string data_space;
  let lbl_end = Compilenv.make_symbol (Some "data_end") in
  declare_global_data lbl_end;
  `{emit_symbol lbl_end}:\n`;
  `    .quad   0\n`;
  (* Emit the frame descriptors *)
  emit_string rodata_space;
  let lbl = Compilenv.make_symbol (Some "frametable") in
  declare_global_data lbl;
  `{emit_symbol lbl}:\n`;
  `    .quad   {emit_int (List.length !frame_descriptors)}\n`;
  List.iter emit_frame !frame_descriptors;
  frame_descriptors := []
